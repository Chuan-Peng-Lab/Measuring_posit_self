---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
# 检查是否已安装 pacman
if (!requireNamespace("pacman", quietly = TRUE)) {
  install.packages("pacman") }   # 如果未安装，则安装包
#install.packages("cowplot")
# 加载所需要的R包
pacman::p_load("tidyverse","bruceR","ggplot2","ggridges","psych","psychTools","DataExplorer","patchwork","cowplot","ggpubr","BayesFactor")
source("R_rainclouds.R")
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
```{r}

    # 获取 phase_0xx 文件夹下所有 CSV 文件的路径
    csv_files <- list.files(path = "../../Data/all/", pattern = "\\.csv$", full.names = TRUE)
    print(csv_files)
    # 循环读取每个 CSV 文件
    for (csv_file in csv_files) {
      var_name <- tools::file_path_sans_ext(basename(csv_file))
      assign(var_name, read.csv(csv_file, fileEncoding = 'UTF-8', header = TRUE))
    }
  

```


```{r 按匹配与不匹配绘制acc和RT}
ALT1_data <- ALT1_all%>%mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct = ifelse(correct == "true", 1, ifelse(correct == "false", 0, NA)))%>% ##重编码correct，1对0错
  filter(screen_id%in%c("formal_ALT1_1","formal_ALT1_2") )%>% #选择正式实验的数据
  group_by(ID,conditionType,condition) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),#每个被试在类似"circle_match"条件下所有trial的平均反应时
    max_rt = max(rt, na.rm = TRUE),#每个被试在类似"circle_match"条件下所有trial的最大反应时
    min_rt = min(rt, na.rm = TRUE),#每个被试在类似"circle_match"条件下所有trial的最小反应时
    sd_rt=sd(rt, na.rm = TRUE), #每个被试在类似"circle_match"条件下所有trial的反应时的方差
    all_count=n(),#每个被试在每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /all_count ,#计算每个被试在每个条件的正确率= 正确/总数
  )
print(ALT1_data)
print(describe(ALT1_data))
```
# 查看ALT1的匹配与不匹配的正确率和反应时的分布
```{r 按匹配与不匹配绘制acc和RT}
ALT1_data2 <- ALT1_data%>%
  group_by(conditionType,condition)%>%
  reframe(
     mean_rt= mean(avg_rt), #每个被试在该条件下的平均反应时（每个被试一个值avg_rt)的平均值
    se_rt=sd(avg_rt) / sqrt(length(avg_rt)), #每个被试在该条件下的平均反应时（avg_rt)的标准误
    mean_acc=mean(acc), #每个被试在该条件下的正确率（每个被试一个值acc)的平均值
    se_acc=sd(acc)/sqrt(length(acc))#每个被试在该条件下的正确率（acc)的标准误
)
print(ALT1_data2)
```
```{r bar_plot of rt in ALT1}
ALT1_plot_rt <- ALT1_data2%>%
  ggplot(., aes(x = condition, y = mean_rt, fill = conditionType)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean_rt - se_rt, ymax = mean_rt + se_rt), position = position_dodge(width = 0.8), width = 0.25)+
  geom_text(
    aes(label = round(mean_rt)),  # Add labels rounded to the nearest integer
    position = position_dodge(width = 0.8),
    vjust = -0.8,  # Adjust vertical position of labels
    size = 3  # Adjust label size if needed
  )+
  scale_fill_grey(start = 0.3) +
  scale_y_continuous(limits = c(0, 900), breaks = seq(0, 900, 50), expand = c(0, 0)) +
 guides(fill = guide_legend(title = "Identity"))+
  theme_minimal()  +
  labs(
    x = "condition",
    y = "RT",
    title = "RT of ALT1 in Different condition",
    caption = "Error bars indicate a standard error"
  )  +
  theme(
    plot.title = element_text(size = 20,
                              face = "bold",
                              margin = margin(b = 35)),
    
    axis.line = element_line(color = "#3D4852"),
    axis.ticks = element_line(color = "#3D4852"),
    panel.grid.major.y = element_line(color = "#DAE1E7"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.y = element_blank()
  )  
print(ALT1_plot_rt)
```
```{r bar_plot of acc in ALT1}
ALT1_plot_ACC <- ALT1_data2%>%
  ggplot(., aes(x = condition, y = mean_acc, fill = conditionType)) +
  geom_bar(stat = "identity", position = position_dodge(), na.rm = TRUE) +
  geom_errorbar(aes(ymin = mean_acc - se_acc, ymax = mean_acc + se_acc), position = position_dodge(width = 0.8), width = 0.25)+
  geom_text(
    aes(label = round(mean_acc, digits = 2)),  # Add labels rounded to the nearest integer
    position = position_dodge(width = 0.6),
    vjust = -0.8,  # Adjust vertical position of labels
    size = 3  # Adjust label size if needed
  )+
  scale_fill_grey(start = 0.3) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.1),expand = c(0, 0.1)) +
 guides(fill = guide_legend(title = "Identity"))+
  theme_minimal()  +
  labs(
    x = "condition",
    y = "ACC",
    title = "ACC of ALT1 in Different condition",
    caption = "Error bars indicate a standard error"
  )  +
  theme(
    plot.title = element_text(size = 20,
                              face = "bold",
                              margin = margin(b = 35)),
    
    axis.line = element_line(color = "#3D4852"),
    axis.ticks = element_line(color = "#3D4852"),
    panel.grid.major.y = element_line(color = "#DAE1E7"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.y = element_blank()
  )  
print(ALT1_plot_ACC)
```

```{r 按匹配与不匹配绘制acc和RT}
acc_and_rt_plots <- function(data,output_file) {
  print(data)

# ACC plot
  acc_plot <- ggplot(data, aes(x = condition, y = acc, fill = conditionType, colour = conditionType)) +
    geom_flat_violin(position = position_nudge(x = .25, y = 0), adjust = 2, trim = FALSE) +
    geom_point(position = position_jitter(width = .15), size = .25) +
    geom_boxplot(aes(x = condition, y = acc), outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
    ylab('Acc') + xlab('conditionType') + coord_flip() +
    theme_cowplot() + guides(fill = FALSE, colour = FALSE) +
    scale_colour_brewer(palette = "Dark2") +
    scale_fill_brewer(palette = "Dark2") +
    ggtitle("Figure 1a: ACC of ALT1")

  # RT plot
  rt_plot <- ggplot(data, aes(x = condition, y = avg_rt, fill = conditionType, colour = conditionType)) +
    geom_flat_violin(position = position_nudge(x = .25, y = 0), adjust = 2, trim = FALSE) +
    geom_point(position = position_jitter(width = .15), size = .25) +
    geom_boxplot(aes(x = condition, y = avg_rt), outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
    ylab('RT') + xlab('conditionType') + coord_flip() +
    theme_cowplot() + guides(fill = FALSE, colour = FALSE) +
    scale_colour_brewer(palette = "Dark2") +
    scale_fill_brewer(palette = "Dark2") +
    ggtitle("Figure 1b: RT of ALT1")

  # Combine plots vertically
  final_plot <- acc_plot | rt_plot
   ggsave(output_file, final_plot, width = 10, height = 15)
  print(final_plot)
}


# 使用函数并传递ALT1_plot_phase_003作为参数
ALT1_plot <- acc_and_rt_plots(ALT1_data,"../../Data/all/ALT1_plot.png")

```

```{r ALT1_ACC_ANOVA}
  ALT1_ACC <-ALT1_data%>% 
  #ungroup()%>%
  MANOVA(., dv = "acc", subID="ID",
       within=c("conditionType", "condition"),
       sph.correction="GG") %>%
    EMMEANS("conditionType", by = "condition") %>%
    EMMEANS("condition", by = "conditionType")


  print(ALT1_ACC)
```


```{r ALT1_RT_ANOVA}
  ALT1_RT <-ALT1_data%>% 
  #ungroup()%>%
  MANOVA(., dv = "avg_rt", subID="ID",
       within=c("conditionType", "condition"),
       sph.correction="GG") %>%
    EMMEANS("conditionType", by = "condition") %>%
    EMMEANS("condition", by = "conditionType")


  print(ALT1_RT)
```

```{r}

```









#IAT
#Built-in error penalty procedure (preferred) Each trial’s latency is recorded to occurrence of the trial’s correct response; trials on which errors preceded the correct responses are included
#IAT only 3,4,6,7 block，区分联合任务为A相容,B;不相容;e.g. 3=A1,4=A2
  -   ① Designate combined tasks as A (for which faster performance will produce a positive score) and B (for which faster performance will produce a negative score). With counterbalancing, half of subjects will encounter A in Blocks 3 & 4, half in Blocks 6 & 7
  -   ②Discard all trials in Blocks 1, 2, and 5
  -   ③Identify blocks for combined task A as A1 and A2; those for combined task B as B1 and B2. If task A is Blocks 3 & 4, Block 3 is A1, Block 4 is A2
# ④Eliminate from remaining data (Blocks 3, 4, 6, and 7) only trials with latencies > 10,000 ms
# ⑤Eliminate all subjects for whom more than 10% of remaining trials have latencies faster than 300 ms
# ⑥Compute latency means (MnA1, MnA2, MnB1, MnB2) and SDs (SDA1, SDA2, SDB1, SDB2) for each of the four blocks for all remaining trials
# ⑦Compute two mean latency differences: B1–A1 = (MnB1 – MnA1) and B2–A2 = (MnB2 – MnA2)
# ⑧Compute an inclusive (not pooled) SD1 using all latencies in Blocks A1 & B1; another (SD2) using all latencies for A2 & B2 (SD2). These can be computed from means and SDs from Step 6 as shown in the lines below this table

# ⑨(B1-A1)/SD1,(B2-A2)/SD2
# ⑩D =  [(B1-A1)/SD1+(B2-A2)/SD2]/2

绝对值：0.2 = 小效应，0.5 = 中等效应，0.8 = 大效应


```{r IAT数据处理}
IAT_data <- IAT_all%>%
  mutate(ID = as.character(ID)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>%
  group_by(ID) %>%
  mutate(
    version_attrib = case_when(
      task_id == "ability"~ (version_attrib[response == "0"& !is.na(version_attrib)]),
      TRUE ~ version_attrib),
    version_target = case_when(
      task_id == "ability"~ (version_target[response == "0"& !is.na(version_target)]),
      TRUE ~ version_target),
    version_attrib2 = case_when(
      task_id == "moral"~ (version_attrib2[response == "0"& !is.na(version_attrib2)]),
      TRUE ~ version_attrib2),
    version_target2 = case_when(
      task_id == "moral"~ (version_target2[response == "0"& !is.na(version_target2)]),
      TRUE ~ version_target2))%>%
  mutate(version = NA)%>%
  mutate(
    version = case_when(
    version_attrib == version_target & task_id == "ability" & screen_id == 3 ~ "A1",#相容为A，不相容为B，练习阶段为1，正式为2
    version_attrib == version_target & task_id == "ability" & screen_id == 4 ~ "A2",
    version_attrib == version_target & task_id == "ability" & screen_id == 6 ~ "B1",
    version_attrib == version_target & task_id == "ability" & screen_id == 7 ~ "B2",
    
    version_attrib != version_target & task_id == "ability" & screen_id == 3 ~ "B1",
    version_attrib != version_target & task_id == "ability" & screen_id == 4 ~ "B2",
    version_attrib != version_target & task_id == "ability" & screen_id == 6 ~ "A1",
    version_attrib != version_target & task_id == "ability" & screen_id == 7 ~ "A2",
    
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 3 ~ "A1",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 4 ~ "A2",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 6 ~ "B1",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 7 ~ "B2",
    
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 3 ~ "B1",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 4 ~ "B2",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 6 ~ "A1",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 7 ~ "A2",
      TRUE ~ version  # 如果没有满足条件的情况，保持原值
    )) %>%
    filter(screen_id %in% c(3, 4, 6, 7)) %>%
  filter(rt<=10000)%>%
   mutate(
    block_type = case_when(
      version %in% c("A1", "A2") ~ "compatible",
      version %in% c("B1", "B2") ~ "incompatible",))

  IAT_data1<-IAT_data%>%
    group_by(ID,task_id,block_type,version) %>%  ##condition是4类标签的，task_id是moral和ability，version是A1,A2,B1,B2
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n(),
    se_rt = sd(rt) / sqrt(row_n))
print(IAT_data1)


```

# IAT block_type(compatible,incompatible)*task_id(moral,	ability)
```{r IAT block_type(compatible,incompatible)*task_id(moral,	ability)}
IAT_RT_plot <- function(data,data_al,dat) {

#方差分析结果
  
IAT_ANOVA <-data%>% MANOVA(.,
       subID="ID",
       dv="mean_rt",
       within=c("task_id","block_type"),)%>%#condition是4类标签的，task_id是moral和ability，block_type是匹配，不匹配
 EMMEANS("task_id", by="block_type") %>%
  EMMEANS("block_type", by="task_id")


 IAT_dat<-IAT_data%>%
    group_by(task_id,block_type) %>%  ##condition是4类标签的，task_id是moral和ability，version是A1,A2,B1,B2
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n(),
    se_rt = sd(rt) / sqrt(row_n))
 print(IAT_dat)
 
  IAT_data_al<-IAT_data%>%
    group_by(ID,block_type,version) %>%  ##condition是4类标签的，task_id是moral和ability，version是A1,A2,B1,B2
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n(),
    se_rt = sd(rt) / sqrt(row_n))%>%
  mutate(task_id="all")%>%
  bind_rows(IAT_data1,.)%>%#将两个子领域的D与总的D合并
  arrange(ID)
  print(IAT_data_al)
  # 创建rt的雨云图
  rt_plot1 <- ggplot(IAT_data_al ,aes(x=block_type,y=mean_rt, fill =block_type, colour =block_type))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =block_type, y =mean_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~task_id)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle(" RT of IAT in different domains")
  
  print(IAT_ANOVA)
  print(rt_plot1)
  
 IAT_plot_rt <- IAT_dat%>%
 ungroup()%>%
   group_by(task_id,block_type)%>%
  ggplot(., aes(x = task_id, y = mean_rt, fill = block_type)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean_rt - se_rt, ymax = mean_rt + se_rt), position = position_dodge(width = 0.8), width = 0.25)+
  geom_text(
    aes(label = round(mean_rt,digits=3)),  # Add labels rounded to the nearest integer
    position = position_dodge(width = 0.8),
    vjust = -0.8,  # Adjust vertical position of labels
    size = 3  # Adjust label size if needed
  )+
  scale_fill_grey(start = 0.3) +
  scale_y_continuous(limits = c(0, 1000), breaks = seq(0, 1000, 50), expand = c(0, 0)) +
 guides(fill = guide_legend(title = "Condition"))+
  theme_minimal()  +
  labs(
    x = "domain",
    y = "RT",
    title = "RT of IAT in Different domains",
    caption = "Error bars indicate a standard error"
  )  +
  theme(
    plot.title = element_text(size = 20,
                              face = "bold",
                              margin = margin(b = 35)),
    
    axis.line = element_line(color = "#3D4852"),
    axis.ticks = element_line(color = "#3D4852"),
    panel.grid.major.y = element_line(color = "#DAE1E7"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.y = element_blank()
  )  
print(IAT_plot_rt)
}
IAT_RT_plot(IAT_data1,IAT_data)
```




```{r IAT的D值计算}
IAT_data_D<-IAT_data1%>%
  ungroup()%>%
  select(-c("block_type"))%>%
  pivot_wider(names_from = version, values_from = c(mean_rt, sd_rt,row_n)) %>%
  group_by(ID,task_id) %>% #task_id是领域(moral,ability)   #ID,version
  reframe(
    diff_B1A1 = round((mean_rt_B1 - mean_rt_A1), digits = 3),
    diff_B2A2 =round(( mean_rt_B2 - mean_rt_A2), digits = 3),
    SD_B1A1 = round((sqrt((((row_n_A1-1)*(sd_rt_A1^2)+(row_n_B1-1)*(sd_rt_B1^2))+((row_n_A1+row_n_B1)*((mean_rt_A1-mean_rt_B1)^2)/4))/(row_n_A1+row_n_B1-1))), digits = 3),
    SD_B2A2 = round((sqrt((((row_n_A2-1)*(sd_rt_A2^2)+(row_n_B2-1)*(sd_rt_B2^2))+((row_n_A2+row_n_B2)*((mean_rt_A2-mean_rt_B2)^2)/4))/(row_n_A2+row_n_B2-1))), digits = 3),
     D= round(((diff_B1A1/SD_B1A1) + (diff_B2A2/SD_B2A2))/2, digits = 3)
    )%>%
mutate(
    effect = case_when(
      abs(D) <= 0.2 ~ "small",
      abs(D) <= 0.5 ~ "mid",
      TRUE ~ "big")) #分为moral，ability两个领域的IAT_D
print(IAT_data_D)
```
```{r}

IAT_D_plot <- function(data, D) {
  
  IAT_D_al <- data %>%
    select(ID, block_type, version,rt) %>%
  group_by(ID,version)%>%
    summarize(
      mean_rt = mean(rt),
      sd_rt = sd(rt),
      row_n = n(),
    ) %>%
   
    pivot_wider(names_from = version, values_from = c(mean_rt, sd_rt, row_n)) %>%
    reframe(
      diff_B1A1 = round((mean_rt_B1 - mean_rt_A1), digits = 3),
      diff_B2A2 = round((mean_rt_B2 - mean_rt_A2), digits = 3),
      SD_B1A1 = round((sqrt((((row_n_A1-1)*(sd_rt_A1^2)+(row_n_B1-1)*(sd_rt_B1^2))+
                             ((row_n_A1+row_n_B1)*((mean_rt_A1-mean_rt_B1)^2)/4))/(row_n_A1+row_n_B1-1))), digits = 3),
      SD_B2A2 = round((sqrt((((row_n_A2-1)*(sd_rt_A2^2)+(row_n_B2-1)*(sd_rt_B2^2))+
                             ((row_n_A2+row_n_B2)*((mean_rt_A2-mean_rt_B2)^2)/4))/(row_n_A2+row_n_B2-1))), digits = 3),
      D = round(((diff_B1A1/SD_B1A1) + (diff_B2A2/SD_B2A2))/2, digits = 3)
    ) %>%
    mutate(task_id = "all") %>%
    mutate(
      effect = case_when(
        abs(D) <= 0.2 ~ "small",
        abs(D) <= 0.5 ~ "mid",
        TRUE ~ "big")
    ) %>%
    bind_rows(D,.)%>%
    arrange(ID)
  print(IAT_D_al) 
  
  IAT_result <- ggplot(IAT_D_al, aes(x = task_id, y = D)) +
    geom_boxplot(aes(color = task_id)) +
    geom_jitter(width = 0.2, alpha = 0.5) +
    labs(x = "Task", y = "D Value", title = "IAT") +
    theme_minimal()
  print(IAT_result)
  
  IAT_summary <- IAT_D_al %>%
    group_by(task_id) %>%
    summarise(
      avg_D = mean(D, na.rm = TRUE),
      max_D = max(D, na.rm = TRUE),
      min_D = min(D, na.rm = TRUE),
      sd_D = sd(D, na.rm = TRUE),
      lower_95 = quantile(D, 0.025, na.rm = TRUE),
      upper_95 = quantile(D, 0.975, na.rm = TRUE)
    )
  print(IAT_summary)
  
  IAT_selected_data <- IAT_D_al %>%
    filter(task_id %in% c("moral", "ability"))%>%
    select(ID,task_id,D)%>%
  pivot_wider(names_from = task_id, values_from = D)
 print(IAT_selected_data)

 paired_t_test_result <- TTEST(IAT_selected_data, y=c("moral", "ability"), paired=TRUE)
  
 print(paired_t_test_result)
  
}

IAT_D_plot(IAT_data, IAT_data_D)

```
```{r}

```

