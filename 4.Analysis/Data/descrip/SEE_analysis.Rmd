---
title: "Basic analysis"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 



```{r setup, include=FALSE}
getwd() #查看工作目录，
```
Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
### 加载R包

```{r create environment}
# 检查是否已安装 pacman
if (!requireNamespace("pacman", quietly = TRUE)) {
  install.packages("pacman") }   # 如果未安装，则安装包
#install.packages("cowplot")
# 加载所需要的R包
pacman::p_load("tidyverse","bruceR","ggplot2","ggridges","psych","psychTools","DataExplorer","patchwork","cowplot")
source("R_rainclouds.R")
```


```{r save all variable from a folder, echo=FALSE}


# 设置文件夹路径

folder_path <- "../../Data/clean/"

getwd()
# 使用list.files函数搜索以"phase_003.csv"为后缀结尾的文件
file_list <- list.files(path = folder_path, pattern = "\\phase_003.csv$", full.names = TRUE, recursive = TRUE)

# file_list现在包含了所有匹配的文件的完整路径

print(file_list)


# 使用for循环读取文件并保存为相应的变量
for (file_name in file_list) {
  # 获取文件名（不包含路径和扩展名）
  var_name <- tools::file_path_sans_ext(basename(file_name))
  
  # 读取文件并保存为相应的变量
  assign(var_name, read.csv(file_name, fileEncoding = 'UTF-8',header = TRUE))
}

```

# 选出完整参与了day0 ~ day3 实验的被试
```{r select subjects join all experiments}
subj_phase_003 <- unique(day2_q_phase_003$ID)
print(subj_phase_003)
```

ALT1
1.filter rt>=200 ,rt<=1200
2.group_by(subj_idx,con),calculate avg_rt,acc

ALT2
1.mutate con2,Image_identity
2.mutate rt2=rt-avg_rt
3.within MANOVA(within.3, dvs="A1B1C1:A2B2C2", dvs.pattern="A(.)B(.)C(.)",
       within=c("A", "B", "C"))
```{r 按匹配与不匹配绘制acc和RT}
ALT1_plot_phase_003 <- subset(ALT1_phase_003, ID %in% subj_phase_003)%>%
 # filter(., ID != "phase_003_subj_14")%>%#不需要每次有这行代码，本次去除是因为被试重复作答
  mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct = ifelse(correct == "true", 1, ifelse(correct == "false", 0, NA)))%>% ##重编码correct，1对0错
  filter(screen_id%in%c("formal_ALT1_1","formal_ALT1_2") )%>% #选择正式实验的数据
  group_by(ID,conditionType) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /all_count #计算正确率= 正确/总数
  )
```

# 查看ALT1的匹配与不匹配的正确率和反应时的分布
```{r 按匹配与不匹配绘制acc和RT}
acc_and_rt_plots <- function(data) {
  # 创建acc的雨云图
  acc_plot <- ggplot(data,aes(x=conditionType,y=acc, fill =conditionType, colour = conditionType))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = conditionType, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('conditionType')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 1a: ACC of ALT1")

  # 创建avg_rt的雨云图 
  rt_plot <- ggplot(data,aes(x=conditionType,y=avg_rt, fill =conditionType, colour = conditionType))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = conditionType, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('RT')+xlab('conditionType')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 1b: RT of ALT1")
  


  # 使用patchwork拼接两个图
  final_plot <- (acc_plot | rt_plot)
  
  return(final_plot)
}

# 使用函数并传递ALT1_plot_phase_003作为参数
ALT1_plot <- acc_and_rt_plots(ALT1_plot_phase_003)

# 显示拼接后的图
print(ALT1_plot)
```
```{r 按condition图形绘制acc和RT}
ALT1_plot2_phase_003 <- subset(ALT1_phase_003, ID %in% subj_phase_003)%>%
 # filter(., ID != "phase_003_subj_14")%>%#不需要每次有这行代码，本次去除是因为被试重复作答
  mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct = ifelse(correct == "true", 1, ifelse(correct == "false", 0, NA)))%>% ##重编码correct，1对0错
  filter(screen_id%in%c("formal_ALT1_1","formal_ALT1_2") )%>% #选择正式实验的数据
  group_by(ID,condition) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /all_count #计算正确率= 正确/总数
  )
```
# 查看ALT1的各个图形的正确率和反应时的分布
```{r 按condition绘制acc和RT}
acc_and_rt_plots2 <- function(data) {
  # 创建acc的雨云图
  acc_plot <- ggplot(data,aes(x=condition,y=acc, fill =condition, colour =condition))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = condition, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 2a: ACC of ALT1")


  
  # 创建avg_rt的雨云图 
  rt_plot <- ggplot(data,aes(x=condition,y=avg_rt, fill =condition, colour = condition))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = condition, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('RT')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 2b: RT of ALT1")

  # 使用patchwork拼接两个图
  final_plot <- (acc_plot | rt_plot)
  
  return(final_plot)
}

# 使用函数并传递ALT1_plot_phase_003作为参数
ALT1_plot2 <- acc_and_rt_plots2(ALT1_plot2_phase_003)

# 显示拼接后的图
print(ALT1_plot2)
```

# 查看ALT2的匹配与不匹配的正确率和反应时的分布

```{r 先准备ALT2数据acc和RT}
ALT2_plot_phase_003 <- subset(ALT2_phase_003, ID %in% subj_phase_003)%>%
 # filter(., ID != "phase_003_subj_14")%>%#不需要每次有这行代码，本次去除是因为被试重复作答
  mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  filter(screen_id%in%c("moral","ability") )%>% #选择正式实验的数据
  group_by(ID,identity,person,domain,valence) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /all_count #计算正确率= 正确/总数
  )
```

```{r ALT2_identity}
ALT2_acc_plot <- function(data) {
  # 创建acc的雨云图
  acc_plot1 <- ggplot(data %>% filter(domain %in% c("moral")),aes(x=identity,y=acc, fill =identity, colour =identity))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = identity, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 3a: ACC of ALT2_moral")


  
  # 创建avg_rt的雨云图 
  acc_plot2 <- ggplot(data %>% filter(domain %in% c("ability")),aes(x=identity,y=acc, fill =identity, colour =identity))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = identity, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 3b: ACC of ALT2_ability")

  # 使用patchwork拼接两个图
  final_plot <- (acc_plot1 / acc_plot2)
  
  return(final_plot)
}
ALT2_acc_plot(ALT2_plot_phase_003)
```
```{r ALT2_valence}
ALT2_acc_plot2 <- function(data) {
  # 创建acc的雨云图
  acc_plot1 <- ggplot(data %>% filter(domain %in% c("moral")),aes(x=valence,y=acc, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = valence, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 4a: ACC of ALT2_moral")


  
  # 创建avg_rt的雨云图 
  acc_plot2 <- ggplot(data %>% filter(domain %in% c("ability")),aes(x=valence,y=acc, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = valence, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 4b: ACC of ALT2_ability")

  # 使用patchwork拼接两个图
  final_plot <- (acc_plot1 / acc_plot2)
  
  return(final_plot)
}
ALT2_acc_plot2(ALT2_plot_phase_003)
```

```{r ALT2_identity}
ALT2_rt_plot <- function(data) {
  # 创建acc的雨云图
  rt_plot1 <- ggplot(data %>% filter(domain %in% c("moral")),aes(x=identity,y=avg_rt, fill =identity, colour =identity))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = identity, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 5a: RT of ALT2_moral")


  
  # 创建avg_rt的雨云图 
  rt_plot2 <- ggplot(data %>% filter(domain %in% c("ability")),aes(x=identity,y=avg_rt, fill =identity, colour =identity))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = identity, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 5b: RT of ALT2_ability")

  # 使用patchwork拼接两个图
  final_plot <- (rt_plot1 / rt_plot2)
  
  return(final_plot)
}
ALT2_rt_plot(ALT2_plot_phase_003)
```
```{r ALT2_valence}
ALT2_rt_plot2 <- function(data) {
  # 创建acc的雨云图
  rt_plot1 <- ggplot(data %>% filter(domain %in% c("moral")),aes(x=valence,y=avg_rt, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =valence, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 6a: RT of ALT2_moral")


  
  # 创建avg_rt的雨云图 
  rt_plot2 <- ggplot(data %>% filter(domain %in% c("ability")),aes(x=valence,y=avg_rt, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = valence, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 6b: RT of ALT2_ability")

  # 使用patchwork拼接两个图
  final_plot <- (rt_plot1 / rt_plot2)
  
  return(final_plot)
}
ALT2_rt_plot2(ALT2_plot_phase_003)
```

```{r}
ALT1_pre2_TTEST<-ALT1_pre2%>%
  mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(recode(correct,"true"="1","false"="0")))%>% ##重编码correct，1对0错
  filter(screen_id%in%c("formal_ALT1_1","formal_ALT1_2") )%>% 
   filter(rt >= 200 & rt <= 1200, correct == 1)%>%
  group_by(ID,conditionType)%>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE),)%>%
  ungroup()%>%
 pivot_wider(names_from =conditionType, values_from = c(avg_rt, max_rt, min_rt, sd_rt))%>%
  TTEST(., y=c("avg_rt_match", "avg_rt_nonmatch"), paired=TRUE)
```

```{r}
 
ALT2_pre2_TTEST<-ALT2_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("ability","moral") )%>%
  filter(rt >= 200 & rt <= 1200, correct == 1)%>%
  group_by(subj_idx,identity,screen_id)%>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE),)%>%
  ungroup()%>%
  mutate(con2=paste(screen_id,identity,sep="_"))%>%
  select(subj_idx,con2,avg_rt)%>%
 pivot_wider(names_from =con2, values_from = avg_rt)%>%
  TTEST(., y=c("ability_match", "ability_nonmatch","moral_match", "moral_nonmatch"), paired=TRUE)

```
```{r rt}
ALT2_pre2_analysis<-ALT2_pre2 %>%
  mutate(domain = case_when(
    grepl("好|坏", condition) ~ "moral",
    grepl("强|弱", condition) ~ "ability",
    TRUE ~ NA_character_),
  person = case_when(
    grepl("我", condition) ~ "self",
    grepl("他|她", condition) ~ "friend",
    TRUE ~ NA_character_),
  valence = case_when(
    grepl("强|好", condition, ignore.case = TRUE) ~ "positive",
    grepl("弱|坏", condition, ignore.case = TRUE) ~ "negative",
    TRUE ~NA_character_
  ))   %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("ability","moral") )%>% #选择正式实验的数据
  filter(rt >= 200 & rt <= 1200, correct == 1)%>%
  group_by(subj_idx,domain,person,identity,valence) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
   
  )%>%
MANOVA(.,
       subID="subj_idx",
       dv="avg_rt",
       within=c("domain","person","identity","valence"),)%>%
  EMMEANS(c("person","valence"), by="domain") %>%
   EMMEANS("identity", by=c("person","valence")) %>%
 EMMEANS("domain", by="person") %>%
  EMMEANS(c("domain", "person"), by="identity") %>%
  EMMEANS(c("domain", "person"), by="valence") %>%
  EMMEANS("domain", by=c("person", "identity"))
```


```{r rt}
ALT2_subj1_anal<-ALT2_subj1 %>%
  mutate(domain = case_when(
    grepl("好|坏", condition) ~ "moral",
    grepl("强|弱", condition) ~ "ability",
    TRUE ~ NA_character_),
  person = case_when(
    grepl("我", condition) ~ "self",
    grepl("他|她", condition) ~ "friend",
    TRUE ~ NA_character_),
  valence = case_when(
    grepl("强|好", condition, ignore.case = TRUE) ~ "positive",
    grepl("弱|坏", condition, ignore.case = TRUE) ~ "negative",
    TRUE ~NA_character_
  ))%>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("ability","moral") )%>% #选择正式实验的数据
  filter(rt >= 200 & rt <= 1200, correct == 1)%>%
  group_by(subj_idx,domain,person,identity,valence) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
   
  )%>%
MANOVA(.,
       subID="subj_idx",
       dv="avg_rt",
       within=c("domain","person","identity","valence"),)%>%
  EMMEANS(c("person","valence"), by="domain") %>%
   EMMEANS("identity", by=c("person","valence")) %>%
 EMMEANS("domain", by="person") %>%
  EMMEANS(c("domain", "person"), by="identity") %>%
  EMMEANS(c("domain", "person"), by="valence") %>%
  EMMEANS("domain", by=c("person", "identity"))
```

```{r}
ALT2_pre2_analysis2<-ALT2_subj1 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(domain = case_when(
    grepl("好|坏", condition) ~ "moral",
    grepl("强|弱", condition) ~ "ability",
    TRUE ~ NA_character_),
  person = case_when(
    grepl("我", condition) ~ "self",
    grepl("他|她", condition) ~ "friend",
    TRUE ~ NA_character_),
  valence = case_when(
    grepl("强|好", condition, ignore.case = TRUE) ~ "positive",
    grepl("弱|坏", condition, ignore.case = TRUE) ~ "negative",
    TRUE ~NA_character_
  )) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("ability","moral") )%>% #选择正式实验的数据
  group_by(subj_idx,domain,person,identity,valence) %>%  #按被试与条件分组
  summarise(
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /  all_count
   
  )%>%
MANOVA(.,
       subID="subj_idx",
       dv="acc",
       within=c("domain","person","identity","valence"),)%>%
 EMMEANS(c("person","valence"), by="domain") %>%
   EMMEANS("identity", by=c("person","valence")) %>%
 EMMEANS("domain", by="person") %>%
  EMMEANS(c("domain", "person"), by="identity") %>%
  EMMEANS(c("domain", "person"), by="valence") %>%
  EMMEANS("domain", by=c("person", "identity"))
```


```{r}

ALT2_subj1_plot2<-ALT2_subj1 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(domain = case_when(
    grepl("好|坏", condition) ~ "moral",
    grepl("强|弱", condition) ~ "ability",
    TRUE ~ NA_character_),
  person = case_when(
    grepl("我", condition) ~ "self",
    grepl("他|她", condition) ~ "friend",
    TRUE ~ NA_character_),
  valence = case_when(
    grepl("强|好", condition, ignore.case = TRUE) ~ "positive",
    grepl("弱|坏", condition, ignore.case = TRUE) ~ "negative",
    TRUE ~NA_character_
  )) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("ability","moral") )%>% #选择正式实验的数据
  group_by(subj_idx,domain,person,identity,valence) %>%   #按被试与条件分组
 summarise(
  all_count = n(),
  row_count = sum(rt >= 200 & rt <= 1200, na.rm = TRUE),
  correct_count = sum(correct == 1 & rt >= 200 & rt <= 1200, na.rm = TRUE),
 acc = correct_count / all_count,
  #.groups = 'keep'
) 
p2<-ggplot(ALT2_subj1_plot2, aes(x = person, y = acc, fill = valence)) +
  geom_boxplot(width = 0.1, color = "black", fill = "white", alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_jitter(aes(color = valence), position = position_jitter(width = 0.15), size = 2, alpha = 0.5, show.legend = FALSE) +
  facet_grid(domain ~ identity + valence) +
  scale_y_continuous(limits = c(0, 1)) +  # 调整纵坐标范围
  scale_fill_manual(values = c("positive" = "lightblue", "negative" = "salmon")) +
  scale_color_manual(values = c("positive" = "blue", "negative" = "red")) +
  labs(x = "Person", y = "Accuracy", title = "Boxplot with Jittered Data Points") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)
)
print(p2)

```


```{r}
ALT2_pre2_analysis2<-ALT2_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(domain = case_when(
    grepl("好|坏", condition) ~ "moral",
    grepl("强|弱", condition) ~ "ability",
    TRUE ~ NA_character_),
  person = case_when(
    grepl("我", condition) ~ "self",
    grepl("他|她", condition) ~ "friend",
    TRUE ~ NA_character_),
  valence = case_when(
    grepl("强|好", condition, ignore.case = TRUE) ~ "positive",
    grepl("弱|坏", condition, ignore.case = TRUE) ~ "negative",
    TRUE ~NA_character_
  ))%>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("ability","moral") )%>% #选择正式实验的数据
  group_by(subj_idx,domain,person,identity,valence) %>%  #按被试与条件分组
  summarise(
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /  all_count
   
  )%>%
MANOVA(.,
       subID="subj_idx",
       dv="acc",
       within=c("domain","person","identity","valence"),)%>%
 EMMEANS(c("person","valence"), by="domain") %>%
   EMMEANS("identity", by=c("person","valence")) %>%
 EMMEANS("domain", by="person") %>%
  EMMEANS(c("domain", "person"), by="identity") %>%
  EMMEANS(c("domain", "person"), by="valence") %>%
  EMMEANS("domain", by=c("person", "identity"))
```

```{r}
library(tidyverse)


ALT2_pre2_plot2<-ALT2_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  mutate(domain = case_when(
    grepl("好|坏", condition) ~ "moral",
    grepl("强|弱", condition) ~ "ability",
    TRUE ~ NA_character_),
  person = case_when(
    grepl("我", condition) ~ "self",
    grepl("他|她", condition) ~ "friend",
    TRUE ~ NA_character_),
  valence = case_when(
    grepl("强|好", condition, ignore.case = TRUE) ~ "positive",
    grepl("弱|坏", condition, ignore.case = TRUE) ~ "negative",
    TRUE ~NA_character_
  ))%>%
   mutate(rt=as.numeric(rt))%>%
  filter(screen_id%in%c("ability","moral") )%>% #选择正式实验的数据
  group_by(subj_idx,domain,person,identity,valence) %>%  #按被试与条件分组
 summarise(
  all_count = n(),
  row_count = sum(rt >= 200 & rt <= 1200, na.rm = TRUE),
  correct_count = sum(correct == 1 & rt >= 200 & rt <= 1200, na.rm = TRUE),
 acc = correct_count / all_count,
  #.groups = 'keep'
) 
p<-ggplot(ALT2_pre2_plot2, aes(x = person, y = acc, fill = valence)) +
  geom_boxplot(width = 0.1, color = "black", fill = "white", alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_jitter(aes(color = valence), position = position_jitter(width = 0.15), size = 2, alpha = 0.5, show.legend = FALSE) +
  facet_grid(domain ~ identity + valence) +
  scale_y_continuous(limits = c(0, 1)) +  # 调整纵坐标范围
  scale_fill_manual(values = c("positive" = "lightblue", "negative" = "salmon")) +
  scale_color_manual(values = c("positive" = "blue", "negative" = "red")) +
  labs(x = "Person", y = "Accuracy", title = "Boxplot with Jittered Data Points") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)
)
print(p)

```
#Built-in error penalty procedure (preferred) Each trial’s latency is recorded to occurrence of the trial’s correct response; trials on which errors preceded the correct responses are included
#① IAT only 3,4,6,7 block，区分联合任务为A,B;e.g. 3=A1,4=A2
[Designate combined tasks as A (for which faster performance will produce a positive score) and B (for which faster performance will produce a negative score). With counterbalancing, half of subjects will encounter A in Blocks 3 & 4, half in Blocks 6 & 7]
#②Discard all trials in Blocks 1, 2, and 5
#③Identify blocks for combined task A as A1 and A2; those for combined task B as B1 and B2. If task A is Blocks 3 & 4, Block 3 is A1, Block 4 is A2
#④Eliminate from remaining data (Blocks 3, 4, 6, and 7) only trials with latencies > 10,000 ms
#⑤Eliminate all subjects for whom more than 10% of remaining trials have latencies faster than 300 ms
#⑥Compute latency means (MnA1, MnA2, MnB1, MnB2) and SDs (SDA1, SDA2, SDB1, SDB2) for each of the four blocks for all remaining trials
#⑦Compute two mean latency differences: B1–A1 = (MnB1 – MnA1) and B2–A2 = (MnB2 – MnA2)
#⑧Compute an inclusive (not pooled) SD1 using all latencies in Blocks A1 & B1; another (SD2) using all latencies for A2 & B2 (SD2). These can be computed from means and SDs from Step 6 as shown in the lines below this table

#⑨(B1-A1)/SD1,(B2-A2)/SD2
#⑩D =  [(B1-A1)/SD1+(B2-A2)/SD2]/2

绝对值：0.2 = 小效应，0.5 = 中等效应，0.8 = 大效应


```{r IAT数据处理}


IAT_phase_003_analysis <- subset(IAT_phase_003, ID %in% subj_phase_003)%>%
  mutate(ID = as.character(ID)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>%
  group_by(ID) %>%
  mutate(
    version_attrib = case_when(
      task_id == "ability"~ (version_attrib[response == "0"& !is.na(version_attrib)]),
      TRUE ~ version_attrib),
    version_target = case_when(
      task_id == "ability"~ (version_target[response == "0"& !is.na(version_target)]),
      TRUE ~ version_target),
    version_attrib2 = case_when(
      task_id == "moral"~ (version_attrib2[response == "0"& !is.na(version_attrib2)]),
      TRUE ~ version_attrib2),
    version_target2 = case_when(
      task_id == "moral"~ (version_target2[response == "0"& !is.na(version_target2)]),
      TRUE ~ version_target2))%>%
  mutate(version = NA)%>%
  mutate(
    version = case_when(
    version_attrib == version_target & task_id == "ability" & screen_id == 3 ~ "A1",
    version_attrib == version_target & task_id == "ability" & screen_id == 4 ~ "A2",
    version_attrib == version_target & task_id == "ability" & screen_id == 6 ~ "B1",
    version_attrib == version_target & task_id == "ability" & screen_id == 7 ~ "B2",
    
    version_attrib != version_target & task_id == "ability" & screen_id == 3 ~ "B1",
    version_attrib != version_target & task_id == "ability" & screen_id == 4 ~ "B2",
    version_attrib != version_target & task_id == "ability" & screen_id == 6 ~ "A1",
    version_attrib != version_target & task_id == "ability" & screen_id == 7 ~ "A2",
    
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 3 ~ "A1",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 4 ~ "A2",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 6 ~ "B1",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 7 ~ "B2",
    
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 3 ~ "B1",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 4 ~ "B2",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 6 ~ "A1",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 7 ~ "A2",
      TRUE ~ version  # 如果没有满足条件的情况，保持原值
    )) 
```

```{r}

IAT_phase_003_RT <- IAT_phase_003_analysis%>%
  filter(screen_id %in% c(3, 4, 6, 7)) %>%
  filter(rt<=10000)%>%
  group_by(ID,task_id,condition,version) %>%  ##subj_idx,
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n()) 


IAT_phase_003_D <- IAT_phase_003_analysis%>%
  filter(screen_id %in% c(3, 4, 6, 7)) %>%
  filter(rt<=10000)%>%
  group_by(ID,task_id, version) %>%  ##subj_idx,
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n()) %>%
  ungroup()%>%
  pivot_wider(names_from = version, values_from = c(mean_rt, sd_rt,row_n)) %>%
  mutate(
    diff_B1A1 = mean_rt_B1 - mean_rt_A1,
    diff_B2A2 = mean_rt_B2 - mean_rt_A2) %>%
  group_by(ID,task_id) %>%##subj_idx,
  summarize(
    SD_B1A1 = sqrt((((row_n_A1-1)*(sd_rt_A1^2)+(row_n_B1-1)*(sd_rt_B1^2))+((row_n_A1+row_n_B1)*((mean_rt_A1-mean_rt_B1)^2)/4))/(row_n_A1+row_n_B1-1)),
    SD_B2A2 = sqrt((((row_n_A2-1)*(sd_rt_A2^2)+(row_n_B2-1)*(sd_rt_B2^2))+((row_n_A2+row_n_B2)*((mean_rt_A2-mean_rt_B2)^2)/4))/(row_n_A2+row_n_B2-1)),
    D=( (diff_B1A1/SD_B1A1)+ (diff_B2A2/SD_B2A2))/2
  )%>%
mutate(
    effect = case_when(
      abs(D) <= 0.2 ~ "small",
      abs(D) <= 0.5 ~ "mid",
      TRUE ~ "big"
    ))
IAT_pre2_D_al <- IAT_pre2_analysis %>%
  filter(screen_id %in% c(3, 4, 6, 7)) %>%
  filter(rt<=10000)%>%
  group_by(subj_idx,version) %>%
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n()) %>%
  ungroup()%>%
  pivot_wider(names_from = version, values_from = c(mean_rt, sd_rt,row_n)) %>%
  mutate(
    diff_B1A1 = mean_rt_B1 - mean_rt_A1,
    diff_B2A2 = mean_rt_B2 - mean_rt_A2) %>%
  group_by(subj_idx) %>%
  summarize(
    SD_B1A1 = sqrt((((row_n_A1-1)*(sd_rt_A1^2)+(row_n_B1-1)*(sd_rt_B1^2))+((row_n_A1+row_n_B1)*((mean_rt_A1-mean_rt_B1)^2)/4))/(row_n_A1+row_n_B1-1)),
    SD_B2A2 = sqrt((((row_n_A2-1)*(sd_rt_A2^2)+(row_n_B2-1)*(sd_rt_B2^2))+((row_n_A2+row_n_B2)*((mean_rt_A2-mean_rt_B2)^2)/4))/(row_n_A2+row_n_B2-1)),
    D=( (diff_B1A1/SD_B1A1)+ (diff_B2A2/SD_B2A2))/2
  )%>%
mutate(
    effect = case_when(
      abs(D) <= 0.2 ~ "small",
      abs(D) <= 0.5 ~ "mid",
      TRUE ~ "big"
    ))%>%
  mutate(task_id="all")
IAT_pre2_D_al <- bind_rows(IAT_pre2_D, IAT_pre2_D_al)%>%
  arrange(subj_idx)

print(IAT_pre2_D_al)

IAT_pre2_summary<-IAT_pre2_D_al%>%
  group_by(task_id)%>%
   summarise(
    avg_D = mean(D, na.rm = TRUE),
    max_D = max(D, na.rm = TRUE),
    min_D = min(D, na.rm = TRUE),
    sd_D=sd(D, na.rm = TRUE))
print(IAT_pre2_summary)
```
```{r IAT_D}
# 从 IAT_pre2_summary 中选择 task_id 为 "morality" 和 "ability" 的行
IAT_selected_data <- IAT_pre2_D_al%>%
  filter(task_id %in% c("moral", "ability"))

# 提取 D 值
morality_D <- IAT_selected_data %>% filter(task_id == "moral") %>% pull(D)
ability_D <- IAT_selected_data %>% filter(task_id == "ability") %>% pull(D)

# 执行配对样本 t 检验
paired_t_test_result <- t.test(morality_D, ability_D, paired = TRUE)

# 输出 t 检验结果
print(paired_t_test_result)

```


```{r IAT}
IAT_result <- ggplot(IAT_pre2_D, aes(x = task_id, y = D)) +
  geom_boxplot(outlier.shape = NA) +  # 不显示异常值
  geom_jitter(aes(color = task_id), width = 0.2, alpha = 0.5) +  # 添加数据点
  labs(x = "Task", y = "D Value", title = "IAT") +
  theme_minimal()
print(IAT_result)
```


```{r SRET EW}
SRET_pre2_EW<-SRET_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("EW_formal") )%>% #选择正式实验的数据
   filter(!word %in% c("务实", "迷糊", "坚贞", "说谎", "主见", "缓慢", "素养", "低俗")) %>%#去掉干扰词
  group_by(subj_idx,person,valence,domain)%>%
  summarize(N_Yes = sum(responses == "yes"),
            N_No = sum(responses == "no"),
            N=n(),
            pro_yes=N_Yes/N,
            avg_rt = mean(rt, na.rm = TRUE),
            sd_rt=sd(rt, na.rm = TRUE)
           )
print(SRET_pre2_EW)

```
```{r}
p_EW<-ggplot(SRET_pre2_EW, aes(x = person, y = pro_yes, fill = valence)) +
  geom_boxplot(width = 0.1, color = "black", fill = "white", alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_jitter(aes(color = valence), position = position_jitter(width = 0.15), size = 2, alpha = 0.5, show.legend = FALSE) +
  facet_grid(domain ~ valence) +
  scale_y_continuous(limits = c(0, 1)) +  # 调整纵坐标范围
  scale_fill_manual(values = c("Positive" = "lightblue", "Negative" = "salmon")) +
  scale_color_manual(values = c("Positive" = "blue", "Negative" = "red")) +
  labs(x = "Person", y = "pro_yes", title = "Ew_YES") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)
)
print(p_EW)
```



```{r}
SRET_pre2_EW_all<-SRET_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("EW_formal") )%>% #选择正式实验的数据
   filter(!word %in% c("务实", "迷糊", "坚贞", "说谎", "主见", "缓慢", "素养", "低俗")) %>%#去掉干扰词
  group_by(subj_idx,person,valence,domain)%>%
  summarize(N_Yes = sum(responses == "yes"),
            N_No = sum(responses == "no"),
            N=n(),
            pro_yes=N_Yes/N,
            avg_rt = mean(rt, na.rm = TRUE),
            sd_rt=sd(rt, na.rm = TRUE)
           )%>%
MANOVA(.,
       subID="subj_idx",
       dv="pro_yes",
       within=c("domain","person","valence"),)%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("person", by="domain") %>%
   EMMEANS("person", by="valence") %>%
  EMMEANS(c("valence", "person"), by="domain") %>%
  EMMEANS("person", by=c("domain", "valence"))
print(SRET_pre2_EW_all)
```

```{r SRET RJ_formal1}
SRET_pre2_RJ <- SRET_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt = as.numeric(rt)) %>%
  mutate(correct = as.numeric(correct)) %>%
  filter(screen_id %in% c("RJ_formal1")) %>%
  filter(!word %in% c("严谨", "认真", "刻板", "白痴", "忠实", "宽宏", "徇私", "可鄙")) %>%
  group_by(subj_idx,valence, domain) %>%
  summarize(
    H = sum(identity == "old" & (responses == "familiar" | responses == "old")),
    M = sum(identity == "old" & (responses == "new" )),
    FA = sum(identity == "new" & (responses == "familiar" | responses == "old")),
    CR = sum(identity == "new" & (responses == "new")),
    P_H = ifelse(is.nan(H / (H + M)), 0, H / (H + M)),
    P_FA = ifelse(is.nan(FA / (FA + CR)), 0, FA / (FA + CR)),
    Correct_recognition = P_H - P_FA,
    avg_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE),
    Z_P_H = qnorm(P_H),
Z_P_FA = qnorm(P_FA),
d_prime = Z_P_H - Z_P_FA
  )%>%
MANOVA(.,
       subID="subj_idx",
       dv="Correct_recognition",#Correct_recognition
       within=c("domain","valence"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("domain", by="valence")

SRET_pre2_RJ
```
```{r SRET RJ_formal1_old}
SRET_pre2_RJ_old <- SRET_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt = as.numeric(rt)) %>%
  mutate(correct = as.numeric(correct)) %>%
  filter(screen_id %in% c("RJ_formal1")) %>%
  filter(!word %in% c("严谨", "认真", "刻板", "白痴", "忠实", "宽宏", "徇私", "可鄙")) %>%
  group_by(subj_idx,person,valence, domain) %>%
  summarize(
    H = sum(identity == "old" & (responses == "familiar" | responses == "old")),
    M = sum(identity == "old" & (responses == "new" )),
    P_H = ifelse(is.nan(H / (H + M)), 0, H / (H + M)),
    Correct_recognition = P_H,
    avg_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE)
  ) %>%
  filter(!is.na(person))%>%
MANOVA(.,
       subID="subj_idx",
       dv="Correct_recognition",
       within=c("domain","valence","person"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS(c("valence", "person"), by="domain") %>%
  EMMEANS("person", by=c("domain", "valence"))

SRET_pre2_RJ_old
```
```{r SRET RJ_formal1_new}
SRET_pre2_RJ_new <- SRET_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt = as.numeric(rt)) %>%
  mutate(correct = as.numeric(correct)) %>%
  filter(screen_id %in% c("RJ_formal1")) %>%
  filter(!word %in% c("严谨", "认真", "刻板", "白痴", "忠实", "宽宏", "徇私", "可鄙")) %>%
    filter(is.na(person))%>%
  group_by(subj_idx,valence, domain) %>%
  summarize(
   
    FA = sum(identity == "new" & (responses == "familiar" | responses == "old")),
    CR = sum(identity == "new" & (responses == "new")),
    P_CR = CR / (FA + CR),
    Correct_recognition = P_CR,
    avg_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE)
  ) %>%

MANOVA(.,
       subID="subj_idx",
       dv="Correct_recognition",
       within=c("domain","valence"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("domain", by="valence")

SRET_pre2_RJ_new
```

```{r SRET RJ_formal1_}
SRET_pre2_RJ_ <- SRET_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt = as.numeric(rt)) %>%
  mutate(correct = as.numeric(correct)) %>%
  filter(screen_id %in% c("RJ_formal1")) %>%
  filter(!word %in% c("严谨", "认真", "刻板", "白痴", "忠实", "宽宏", "徇私", "可鄙")) %>%
  group_by(subj_idx,valence, domain) %>%
  summarize(
    H = sum(correct == 1 ),
   n=n(),
    recognition =H/n,
    avg_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE)
  ) %>%
MANOVA(.,
       subID="subj_idx",
       dv="recognition",
       within=c("domain","valence"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("domain", by= "valence")

SRET_pre2_RJ_
```

```{r SRET RJ_formal2_old}
SRET_pre2_RJ_2 <- SRET_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt = as.numeric(rt)) %>%
  mutate(correct = as.numeric(correct)) %>%
  filter(screen_id %in% c("RJ_formal_2")) %>%
  filter(!word %in% c("严谨", "认真", "刻板", "白痴", "忠实", "宽宏", "徇私", "可鄙")) %>%
   filter(!is.na(identity))%>%
  group_by(subj_idx,valence,identity, domain) %>%
  summarize(
    H = sum(correct == 1 ),
   n=n(),
    recognition =H/n,
    avg_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE)
  ) %>%
MANOVA(.,
       subID="subj_idx",
       dv="recognition",
       within=c("domain","valence","identity"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("domain", by= "valence")

SRET_pre2_RJ_2
```
```{r SRET RJ_formal2}
SRET_pre2_RJ2 <- SRET_pre2 %>%
  mutate(subj_idx = as.character(subj_idx)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt = as.numeric(rt)) %>%
  mutate(correct = as.numeric(correct)) %>%
  filter(screen_id %in% c("RJ_formal_2")) %>%
  filter(!word %in% c("严谨", "认真", "刻板", "白痴", "忠实", "宽宏", "徇私", "可鄙")) %>%
  group_by(subj_idx,valence, domain) %>%
  summarize(
    H = sum(correct == 1 ),
   n=n(),
    recognition =H/n,
    avg_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE)
  )%>%
MANOVA(.,
       subID="subj_idx",
       dv="recognition",
       within=c("domain","valence"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("domain", by= "valence")

SRET_pre2_RJ2
```
#
```{r}
day0to2_q_pre2 <- day0_all_pre2 %>%
  filter(!(ParticipantID %in% c(114, 32))) %>%
  left_join(.,day1_q_pre2, by = "subj_idx") %>%
  left_join( .,day2_q_pre2, by = "subj_idx") %>%
  select(-c("X.x","X.y","ParticipantID.y","ParticipantID.x"))

  day1to3_q_pre2 <-left_join( day1to3_q_pre2,day2_q_pre2, by = "subj_idx") 
 
str(day0to3_q_pre2)
```

```{r}
all_q_pre2 <- day0to2_q_pre2 %>%
  mutate(
    phq_al = rowSums(select(., starts_with("phq")), na.rm = TRUE),
    gad_al = rowSums(select(., starts_with("gad")), na.rm = TRUE),
    selfclarity_al = rowSums(select(., starts_with("selfclarity")), na.rm = TRUE),
    ses_al = rowSums(select(., starts_with("ses")), na.rm = TRUE),
    coreself_al =rowSums(select(., starts_with("coreself")), na.rm = TRUE),
    SGPS_al = rowSums(select(., starts_with("SGPS")), na.rm = TRUE),
    hsns_al = rowSums(select(., starts_with("hsns")), na.rm = TRUE),
    NPI_al = rowSums(select(., starts_with("NPI")), na.rm = TRUE),
    swb_al = rowSums(select(., starts_with("swb")), na.rm = TRUE),
    LOT_al = rowSums(select(., starts_with("LOT")), na.rm = TRUE),
    IPC_al = (rowSums(select(., starts_with("IPC")), na.rm = TRUE)+24)
  )%>%mutate(gad = case_when(
    gad_al >= 0 & gad_al <= 4 ~ "无",
    gad_al >= 5 & gad_al <= 9 ~ "轻度",
    gad_al >= 10 & gad_al <= 14 ~ "中度",
    gad_al >= 15 ~ "重度",
    TRUE ~ NA_character_
  ))%>%
   mutate(phq = case_when(
    phq_al >= 0 & phq_al <= 4 ~ "无",
    phq_al >= 5 & phq_al <= 9 ~ "轻度",
    phq_al >= 10 & phq_al <= 14 ~ "中度",
    phq_al >= 15 & phq_al <= 19 ~ "中重度",
     phq_al >= 20  ~ "重度",
    TRUE ~ NA_character_
  ))

re_all_q_pre2<-day3_q_pre2%>%
  mutate(
    phq_al = rowSums(select(., starts_with("phq")), na.rm = TRUE),
    gad_al = rowSums(select(., starts_with("gad")), na.rm = TRUE),
    selfclarity_al = rowSums(select(., starts_with("selfclarity")), na.rm = TRUE),
    ses_al = rowSums(select(., starts_with("ses")), na.rm = TRUE),
    coreself_al =rowSums(select(., starts_with("coreself")), na.rm = TRUE),
    SGPS_al = rowSums(select(., starts_with("SGPS")), na.rm = TRUE),
    hsns_al = rowSums(select(., starts_with("hsns")), na.rm = TRUE),
    NPI_al = rowSums(select(., starts_with("NPI")), na.rm = TRUE),
    swb_al = rowSums(select(., starts_with("swb")), na.rm = TRUE),
    LOT_al = rowSums(select(., starts_with("LOT")), na.rm = TRUE),
    IPC_al = (rowSums(select(., starts_with("IPC")), na.rm = TRUE)+24)
  )%>%mutate(gad = case_when(
    gad_al >= 0 & gad_al <= 4 ~ "无",
    gad_al >= 5 & gad_al <= 9 ~ "轻度",
    gad_al >= 10 & gad_al <= 14 ~ "中度",
    gad_al >= 15 ~ "重度",
    TRUE ~ NA_character_
  ))%>%
   mutate(phq = case_when(
    phq_al >= 0 & phq_al <= 4 ~ "无",
    phq_al >= 5 & phq_al <= 9 ~ "轻度",
    phq_al >= 10 & phq_al <= 14 ~ "中度",
    phq_al >= 15 & phq_al <= 19 ~ "中重度",
     phq_al >= 20  ~ "重度",
    TRUE ~ NA_character_
  ))
  # 选择包括subj_idx和问卷的列
questionnaires <- c("IPC_al", "LOT_al", "swb_al", "NPI_al", "hsns_al", "SGPS_al", "coreself_al", "ses_al", "selfclarity_al", "gad_al", "phq_al")

# 计算重测信度

# 存储计算的重测信度
reliabilities <- data.frame(questionnaire = character(0), reliability = numeric(0))

for (questionnaire in questionnaires) {
  # 选择两次测量的数据，for循环
  data1 <- all_q_pre2[, c("subj_idx", questionnaire)]
  data2 <- re_all_q_pre2[, c("subj_idx", questionnaire)]
  
  # 合并数据框
  combined_data <- merge(data1, data2, by = "subj_idx", suffixes = c("_1", "_2"))
  
  # 计算重测信度
  reliability <- cor(combined_data[, paste(questionnaire, "_1", sep = "")], combined_data[, paste(questionnaire, "_2", sep = "")],method = "pearson", use = "pairwise")
  
  # 存储结果
  reliabilities <- rbind(reliabilities, data.frame(questionnaire = questionnaire, reliability = reliability))
}

# 输出重测信度
print(reliabilities)



```
```{r}
# 安装并加载 psych 包（如果尚未安装）
# install.packages("psych")
library(psych)

# 从 all_q 数据框中选择包含相关问卷的列
questionnaire_cols <- day0to2_q_pre2%>%
  select(-c("IPC_al", "LOT_al", "swb_al", "NPI_al", "hsns_al", "SGPS_al", "coreself_al", "ses_al", "selfclarity_al", "gad_al", "phq_al"))%>%
[., c("subj_idx", grep("^gad|^phq|^ses|swb^|hsns^|", colnames(day0to2_q_pre2))]

# 计算Cronbach's alpha系数
alpha_result <- alpha(questionnaire_cols)

# 输出内部一致性系数结果
print(alpha_result)

```


#To visualize frequency distributions for all discrete features:

```{r}
all_q_plot_pre2<-all_q_pre2%>%
  select(-c("subj_name","birthday","friend_name.x","X","friend_name.y"))%>%
  mutate(age=as.character(age),
         obj_ses1=as.character(obj_ses1),
         fri_ses2=as.character(fri_ses2),
        sex=case_when(
          sex==0~"male",
          sex==1~"female",
          TRUE ~ as.character(sex) 
        )
         )%>%
  rename(fri_Sex=Sex)%>%
mutate(fatherEdu = case_when(
    fatherEdu == 0 ~ "zero",
    fatherEdu == 1 ~ "elementary",
    fatherEdu == 2 ~ "junior",
    fatherEdu == 3 ~ "senior",
    fatherEdu == 4 ~ "college",
    fatherEdu == 5 ~ "graduate",
    TRUE ~ as.character(fatherEdu)  # 如果没有匹配到上述条件，保持不变
  ))%>%
  mutate(motherEdu = case_when(
    motherEdu == 0 ~ "zero",
    motherEdu == 1 ~ "elementary",
    motherEdu == 2 ~ "junior",
    motherEdu == 3 ~ "senior",
    motherEdu == 4 ~ "college",
    motherEdu == 5 ~ "graduate",
    TRUE ~ as.character(motherEdu)  # 如果没有匹配到上述条件，保持不变
  ))%>%
  mutate(FatherOccupation = case_when(
    FatherOccupation == 0 ~ "临时工",
    FatherOccupation == 1 ~ "个体经营",
    FatherOccupation == 2 ~ "一般管理",
    FatherOccupation == 3 ~ "中层管理",
    FatherOccupation == 4 ~ "高级管理",
    TRUE ~ as.character(FatherOccupation)  # 如果没有匹配到上述条件，保持不变
  ))%>%
  mutate(MotherOccupation = case_when(
    MotherOccupation == 0 ~ "临时工",
    MotherOccupation == 1 ~ "个体经营",
    MotherOccupation == 2 ~ "一般管理",
    MotherOccupation == 3 ~ "中层管理",
    MotherOccupation == 4 ~ "高级管理",
    TRUE ~ as.character(MotherOccupation)  # 如果没有匹配到上述条件，保持不变
  ))%>%
  mutate(income = case_when(
    income == 0 ~ "zero",
    income < 2000 ~ "<2000",
    between(income, 2000, 5000) ~ "2000~5000",
    between(income, 5000, 10000) ~ "5000~10000",
    between(income, 10000, 30000) ~ "10000~30000",
    between(income, 30000, 50000) ~ "30000~50000",
    between(income, 50000, 100000) ~ "50000~100000",
    between(income, 100000, 150000) ~ "100000~150000",
    between(income, 150000, 200000) ~ "150000~200000",
    income >= 200000 ~ "≥200000",
    TRUE ~ as.character(income)  # 如果没有匹配的条件，保持不变
  ))

```


#To visualize distributions for all continuous features:
```{r}
plot_histogram(all_q_plot_pre2)
```
```{r}

```

