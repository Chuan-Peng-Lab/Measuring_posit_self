---
title: "Basic analysis"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 



```{r setup, include=FALSE}
getwd() #查看工作目录，
```
Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
### 加载R包

```{r create environment}
rm(list = ls())
# 检查是否已安装 pacman
if (!requireNamespace("pacman", quietly = TRUE)) {
  install.packages("pacman") }   # 如果未安装，则安装包
#install.packages("cowplot")
# 加载所需要的R包
pacman::p_load("tidyverse","bruceR","ggplot2","ggridges","psych","psychTools","DataExplorer","patchwork","cowplot")
source("R_rainclouds.R")
```



```{r 将本批次的clean data导入环境，储存为变量}


main_folder <- "../../Data/clean/"

# 获取所有子文件夹的路径
subfolders <- list.files(path = main_folder, pattern = "clean_day[0-3]", full.names = TRUE)


for (subfolder in subfolders) {
  phase_folder <- file.path(subfolder, "phase_006")# 循环读取每个子文件夹下的 phase_0xx 文件夹内的 CSV 文件

  # 检查 phase_0xx 文件夹是否存在
  if (dir.exists(phase_folder)) {
    # 获取 phase_0xx 文件夹下所有 CSV 文件的路径
    csv_files <- list.files(path = phase_folder, pattern = "\\.csv$", full.names = TRUE)
    print(csv_files)
    # 循环读取每个 CSV 文件
    for (csv_file in csv_files) {
      var_name <- tools::file_path_sans_ext(basename(csv_file))
      assign(var_name, read.csv(csv_file, fileEncoding = 'UTF-8', header = TRUE))
    }
  }
}

```


# 选出完整参与了day0 ~ day3 实验的被试
```{r select subjects join all experiments}
subj_phase_006 <- unique(day3_q_phase_006$ID)

print(subj_phase_006)
```
```{r 将clean data内的数据根据day3的最终被试选取这部分数据存入select}

select_files <- function(phase) {
  main_folder <- "../../Data/clean/"
 # day3_q <- read.csv( file=paste0("../../Data/clean/clean_day3/",phase,"/day3_q_", phase, ".csv"), fileEncoding = 'UTF-8', header = TRUE)
day3_q <- read.csv( file=paste0("../../Data/clean/clean_day2/",phase,"/day2_q_", phase, ".csv"), fileEncoding = 'UTF-8', header = TRUE)
  # 获取所有子文件夹的路径
  subfolders <- list.files(path = main_folder, pattern = "clean_day[0-3]", full.names = TRUE)
  select_subj <- unique(day3_q$ID)

  for (subfolder in subfolders) {
    phase_folder <- file.path(subfolder, phase)

    # 检查 phase_0xx 文件夹是否存在
    if (dir.exists(phase_folder)) {
      # 获取 phase_0xx 文件夹下所有 CSV 文件的路径
      csv_files <- list.files(path = phase_folder, pattern = "\\.csv$", full.names = TRUE)
      
      # 循环读取每个 CSV 文件
      for (csv_file in csv_files) {
        var_name <- tools::file_path_sans_ext(basename(csv_file))
        data <- read.csv(csv_file, fileEncoding = 'UTF-8', header = TRUE)
        
        # 使用 subset 函数选择符合条件的行
        var_data <- subset(data, ID %in% select_subj)
        
        # 修改输出文件路径
        output_file <- paste0("../../Data/select/", var_name, ".csv")
        
        # 修改写入 csv 文件的语句，指定正确的 data.frame 和文件路径
        write.csv(var_data, file = output_file, row.names = FALSE)
      }
    }
  }
}

select_files("phase_007")
```

```{r 合并select内的各问卷和任务的目前所有阶段的数据储存在all内}
merge_files <- function(prefix) {
  input_folder <- "../../Data/select/"
  output_folder <- "../../Data/all/"

  # Get all files with the specified prefix
  files <- list.files(path = input_folder, pattern = paste0("^", prefix), full.names = TRUE)

  # Check if there are files with the specified prefix
  if (length(files) == 0) {
    cat("No files with the prefix", prefix, "found in the input folder.\n")
    return(NULL)
  }

  # Read and bind all files with the specified prefix
  all_data <- lapply(files, read.csv)
  merged_data <- bind_rows(all_data)

  # Define the output file path
  output_file <- file.path(output_folder, paste0(prefix, "_all.csv"))

  # Write the merged data to the output file
  write.csv(merged_data, file = output_file, row.names = FALSE)

  cat("Merged files with prefix", prefix, "into", output_file, "\n")
}

# Merge files for different prefixes
merge_files("day0")
merge_files("ALT2")
merge_files("day1_q")
merge_files("day2_q")
merge_files("day3_q")
merge_files("ALT1")
merge_files("IAT")
merge_files("SRET")
```

```{r}
all_folder<- "../../Data/all/"
csv_files <- list.files(path = all_folder, pattern = "\\.csv$", full.names = TRUE)
    print(csv_files)
    # 循环读取每个 CSV 文件
    for (csv_file in csv_files) {
      var_name <- tools::file_path_sans_ext(basename(csv_file))
      assign(var_name, read.csv(csv_file, fileEncoding = 'UTF-8', header = TRUE))
    }
```
######*前面储存的是clean data未筛选day3的被试所有数据，所以以下步骤都要先选出最终完整参与全程的被试*

ALT1
1.filter rt>=200 ,rt<=1200
2.group_by(subj_idx,con),calculate avg_rt,acc

ALT2
1.mutate con2,Image_identity
2.mutate rt2=rt-avg_rt
3.within MANOVA(within.3, dvs="A1B1C1:A2B2C2", dvs.pattern="A(.)B(.)C(.)",
       within=c("A", "B", "C"))
```{r 按匹配与不匹配绘制acc和RT}

 ALT1_all_P<-ALT1_all%>%
  mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct = ifelse(correct == "true", 1, ifelse(correct == "false", 0, NA)))%>% ##重编码correct，1对0错
  filter(screen_id%in%c("formal_ALT1_1","formal_ALT1_2") )%>% #选择正式实验的数据
  group_by(ID,conditionType) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /all_count #计算正确率= 正确/总数
  )
print(ALT1_all)
```





# 查看ALT1的匹配与不匹配的正确率和反应时的分布
```{r 按匹配与不匹配绘制acc和RT}
acc_and_rt_plots <- function(data) {
  print(data)
  # 创建acc的雨云图
  acc_plot <- ggplot(data,aes(x=conditionType,y=acc, fill =conditionType, colour = conditionType))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = conditionType, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('conditionType')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 1a: ACC of ALT1")

  # 创建avg_rt的雨云图 
  rt_plot <- ggplot(data,aes(x=conditionType,y=avg_rt, fill =conditionType, colour = conditionType))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = conditionType, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('RT')+xlab('conditionType')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 1b: RT of ALT1")

  # 使用patchwork拼接两个图
  final_plot <- (acc_plot | rt_plot)
 print(final_plot)
 
   # 比较匹配与不匹配的rt,配对样本t检验
  ALT1_TTEST <- data %>%
  ungroup()%>%
  select(ID,conditionType,avg_rt, max_rt, min_rt, sd_rt)%>%
  pivot_wider(names_from =conditionType, values_from = c(avg_rt, max_rt, min_rt, sd_rt))%>%
  TTEST(., y=c("avg_rt_match", "avg_rt_nonmatch"), paired=TRUE)
  print(ALT1_TTEST)
  
     # 比较匹配与不匹配的rt,配对样本t检验
  ALT1_TTEST2 <- data %>%
  ungroup()%>%
  select(ID,conditionType,acc)%>%
  pivot_wider(names_from =conditionType, values_from = c(acc))%>%
  TTEST(., y=c("match", "nonmatch"), paired=TRUE)
  print(ALT1_TTEST2)
}

# 使用函数并传递ALT1_plot_phase_003作为参数
ALT1_plot <- acc_and_rt_plots( ALT1_all_P)

```

```{r 按condition图形绘制acc和RT}
ALT1_plot2_phase_004 <- subset(ALT1_phase_004, ID %in% subj_phase_004)%>%
 # filter(., ID != "phase_003_subj_14")%>%#不需要每次有这行代码，本次去除是因为被试重复作答
   ALT1_all_P2<-ALT1_all%>%
  mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct = ifelse(correct == "true", 1, ifelse(correct == "false", 0, NA)))%>% ##重编码correct，1对0错
  filter(screen_id%in%c("formal_ALT1_1","formal_ALT1_2") )%>% #选择正式实验的数据
  group_by(ID,condition) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /all_count #计算正确率= 正确/总数
  )
```

# 查看ALT1的各个图形的正确率和反应时的分布
```{r 按condition绘制acc和RT}
acc_and_rt_plots2 <- function(data) {
  # 创建acc的雨云图
  print(data)
  acc_plot <- ggplot(data,aes(x=condition,y=acc, fill =condition, colour =condition))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = condition, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 2a: ACC of ALT1")


  
  # 创建avg_rt的雨云图 
  rt_plot <- ggplot(data,aes(x=condition,y=avg_rt, fill =condition, colour = condition))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = condition, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('RT')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 2b: RT of ALT1")

  # 使用patchwork拼接两个图
  final_plot <- (acc_plot | rt_plot)
  print(final_plot)
  
}

# 使用函数并传递ALT1_plot_phase_003作为参数
ALT1_plot2 <- acc_and_rt_plots2(ALT1_all_P2)


```

# 查看ALT2的匹配与不匹配的正确率和反应时的分布

```{r 先准备ALT2数据acc和RT}
ALT2_plot_phase_004 <- subset(ALT2_phase_004, ID %in% subj_phase_004)%>%
 # filter(., ID != "phase_003_subj_14")%>%#不需要每次有这行代码，本次去除是因为被试重复作答
  ALT2_all_P<-ALT2_all%>%
  mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  filter(screen_id%in%c("moral","ability") )%>% #选择正式实验的数据
  group_by(ID,identity,person,domain,valence) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /all_count #计算正确率= 正确/总数
  )

ALT2_all_P2<-ALT2_all%>%
 # filter(., ID != "phase_003_subj_14")%>%#不需要每次有这行代码，本次去除是因为被试重复作答
  mutate(ID = as.character(ID)) %>%
   mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  group_by(ID,domain,identity,person,valence) %>%  #按被试与条件分组
  summarise(
    avg_rt = mean(rt, na.rm = TRUE),
    max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
    sd_rt=sd(rt, na.rm = TRUE), #计算平均反应时
    all_count=n(),#每个条件的总trial数量
    row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),  #每个条件反应时符合条件的总数,舍弃按键太快和按键太慢的
    correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
    acc = correct_count /all_count #计算正确率= 正确/总数
  )
print(ALT2_all_P2)
```
# ALT2按match/nonmatch
```{r ALT2_identity}
ALT2_acc_plot <- function(data) {
  print(data)
  # 创建acc的雨云图
  acc_plot1 <- ggplot(data %>% filter(domain %in% c("moral")),aes(x=identity,y=acc, fill =identity, colour =identity))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = identity, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 3a: ACC of ALT2_moral")


  
  # 创建avg_rt的雨云图 
  acc_plot2 <- ggplot(data %>% filter(domain %in% c("ability")),aes(x=identity,y=acc, fill =identity, colour =identity))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = identity, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 3b: ACC of ALT2_ability")

  # 使用patchwork拼接两个图
  final_plot <- (acc_plot1 / acc_plot2)
  
  return(final_plot)
}
ALT2_acc_plot(ALT2_all_P)
```
```{r ALT2_valence}
ALT2_acc_plot2 <- function(data) {
  # 创建acc的雨云图
  acc_plot1 <- ggplot(data %>% filter(domain %in% c("moral")),aes(x=valence,y=acc, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = valence, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 4a: ACC of ALT2_moral")


  
  # 创建avg_rt的雨云图 
  acc_plot2 <- ggplot(data %>% filter(domain %in% c("ability")),aes(x=valence,y=acc, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = valence, y =acc),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('Acc')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 4b: ACC of ALT2_ability")

  # 使用patchwork拼接两个图
  final_plot <- (acc_plot1 / acc_plot2)
  
  return(final_plot)
}
ALT2_acc_plot2(ALT2_all_P2)
```

```{r ALT2_identity}
ALT2_rt_plot <- function(data) {
  # 创建acc的雨云图
  rt_plot1 <- ggplot(data %>% filter(domain %in% c("moral")),aes(x=identity,y=avg_rt, fill =identity, colour =identity))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = identity, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 5a: RT of ALT2_moral")


  
  # 创建avg_rt的雨云图 
  rt_plot2 <- ggplot(data %>% filter(domain %in% c("ability")),aes(x=identity,y=avg_rt, fill =identity, colour =identity))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = identity, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 5b: RT of ALT2_ability")

  # 使用patchwork拼接两个图
  final_plot <- (rt_plot1 / rt_plot2)
  
  return(final_plot)
  
}
ALT2_rt_plot(ALT2_plot_phase_004)
```
```{r ALT2_valence}
ALT2_rt_plot2 <- function(data) {
  a<-describe(data)
print(a)
  # 创建acc的雨云图
  rt_plot1 <- ggplot(data %>% filter(domain %in% c("moral")),aes(x=valence,y=avg_rt, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =valence, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 6a: RT of ALT2_moral")


  
  # 创建avg_rt的雨云图 
  rt_plot2 <- ggplot(data %>% filter(domain %in% c("ability")),aes(x=valence,y=avg_rt, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x = valence, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~person)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 6b: RT of ALT2_ability")

  # 使用patchwork拼接两个图
  final_plot <- (rt_plot1 / rt_plot2)
  
  return(final_plot)
}
ALT2_rt_plot2(ALT2_plot_phase_004)
```


#Built-in error penalty procedure (preferred) Each trial’s latency is recorded to occurrence of the trial’s correct response; trials on which errors preceded the correct responses are included
#IAT only 3,4,6,7 block，区分联合任务为A相容,B;不相容;e.g. 3=A1,4=A2
  -   ① Designate combined tasks as A (for which faster performance will produce a positive score) and B (for which faster performance will produce a negative score). With counterbalancing, half of subjects will encounter A in Blocks 3 & 4, half in Blocks 6 & 7
  -   ②Discard all trials in Blocks 1, 2, and 5
  -   ③Identify blocks for combined task A as A1 and A2; those for combined task B as B1 and B2. If task A is Blocks 3 & 4, Block 3 is A1, Block 4 is A2
# ④Eliminate from remaining data (Blocks 3, 4, 6, and 7) only trials with latencies > 10,000 ms
# ⑤Eliminate all subjects for whom more than 10% of remaining trials have latencies faster than 300 ms
# ⑥Compute latency means (MnA1, MnA2, MnB1, MnB2) and SDs (SDA1, SDA2, SDB1, SDB2) for each of the four blocks for all remaining trials
# ⑦Compute two mean latency differences: B1–A1 = (MnB1 – MnA1) and B2–A2 = (MnB2 – MnA2)
# ⑧Compute an inclusive (not pooled) SD1 using all latencies in Blocks A1 & B1; another (SD2) using all latencies for A2 & B2 (SD2). These can be computed from means and SDs from Step 6 as shown in the lines below this table

# ⑨(B1-A1)/SD1,(B2-A2)/SD2
# ⑩D =  [(B1-A1)/SD1+(B2-A2)/SD2]/2

绝对值：0.2 = 小效应，0.5 = 中等效应，0.8 = 大效应


```{r IAT数据处理}


IAT_phase_004_analysis <- subset(IAT_phase_004, ID %in% subj_phase_004)%>%
  mutate(ID = as.character(ID)) %>%
  mutate(ParticipantID = as.character(ParticipantID)) %>%
  mutate(rt=as.numeric(rt))%>%
  group_by(ID) %>%
  mutate(
    version_attrib = case_when(
      task_id == "ability"~ (version_attrib[response == "0"& !is.na(version_attrib)]),
      TRUE ~ version_attrib),
    version_target = case_when(
      task_id == "ability"~ (version_target[response == "0"& !is.na(version_target)]),
      TRUE ~ version_target),
    version_attrib2 = case_when(
      task_id == "moral"~ (version_attrib2[response == "0"& !is.na(version_attrib2)]),
      TRUE ~ version_attrib2),
    version_target2 = case_when(
      task_id == "moral"~ (version_target2[response == "0"& !is.na(version_target2)]),
      TRUE ~ version_target2))%>%
  mutate(version = NA)%>%
  mutate(
    version = case_when(
    version_attrib == version_target & task_id == "ability" & screen_id == 3 ~ "A1",
    version_attrib == version_target & task_id == "ability" & screen_id == 4 ~ "A2",
    version_attrib == version_target & task_id == "ability" & screen_id == 6 ~ "B1",
    version_attrib == version_target & task_id == "ability" & screen_id == 7 ~ "B2",
    
    version_attrib != version_target & task_id == "ability" & screen_id == 3 ~ "B1",
    version_attrib != version_target & task_id == "ability" & screen_id == 4 ~ "B2",
    version_attrib != version_target & task_id == "ability" & screen_id == 6 ~ "A1",
    version_attrib != version_target & task_id == "ability" & screen_id == 7 ~ "A2",
    
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 3 ~ "A1",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 4 ~ "A2",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 6 ~ "B1",
    version_attrib2 == version_target2 & task_id == "moral" & screen_id == 7 ~ "B2",
    
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 3 ~ "B1",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 4 ~ "B2",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 6 ~ "A1",
    version_attrib2 != version_target2 & task_id == "moral" & screen_id == 7 ~ "A2",
      TRUE ~ version  # 如果没有满足条件的情况，保持原值
    )) 

```

```{r}
raw_day1<-read.csv("../../Data/raw/day1/phase_004/day1_phase_004.csv")#修改phase_002

IAT_order <- function(data,IAT_analysis) {

  trial_idx_IAT_moral <- data %>%
    group_by(ID) %>%
    filter(task_id == "moral") %>%
    summarize(trial_idx_IAT_moral = min(trial_index))
  
   trial_idx_IAT_ability <- data %>%
    group_by(ID) %>%
    filter(task_id == "ability") %>%
    summarize(trial_idx_IAT_ability = min(trial_index))
   
  block_order<-IAT_analysis%>%
    select(ID,screen_id,version,task_id)%>%
    filter(version== "A1")%>%
    distinct()%>%
    group_by(ID) %>%
     mutate( block_order = ifelse((version== "A1" & screen_id =="3") , "compatible", "incompatible"))
  
  merged_data <- merge(trial_idx_IAT_ability, trial_idx_IAT_moral, by = "ID", all = TRUE)%>%
    merge(block_order,by = "ID", all = TRUE)%>%
   # filter(version_attrib %in% c(1, 2) |version_attrib2 %in% c(1, 2) ) %>% 
    #select(ID, version_attrib,version_target,version_attrib2,version_target2)%>%
  mutate(IAT_first = ifelse(trial_idx_IAT_moral < trial_idx_IAT_ability, "moral_first", "ability_first"))%>%
    subset(., ID %in% subj_phase_004)
  print(merged_data)
}

IAT_order(raw_day1,IAT_phase_004_analysis)
```
# IAT block_type(compatible,incompatible)*task_id(moral,	ability)
```{r IAT block_type(compatible,incompatible)*task_id(moral,	ability)}
IAT_rt_plot <- function(data) {

  data<-data%>%
    filter(screen_id %in% c(3, 4, 6, 7)) %>%
  filter(rt<=10000)%>%
   mutate(
    block_type = case_when(
      version %in% c("A1", "A2") ~ "compatible",
      version %in% c("B1", "B2") ~ "incompatible",))%>%
   group_by(ID,task_id,block_type) %>%  ##condition是4类标签的，task_id是moral和ability，version是A1,A2,B1,B2
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n())
    print(data)
    
    a<-describe(data)
print(a)
IAT_ANOVA <-data%>% MANOVA(.,
       subID="ID",
       dv="mean_rt",
       within=c("task_id","block_type"),)%>%#condition是4类标签的，task_id是moral和ability，block_type是匹配，不匹配
 EMMEANS("task_id", by="block_type") %>%
  EMMEANS("block_type", by="task_id")
  # 创建acc的雨云图
  rt_plot1 <- ggplot(data ,aes(x=block_type,y=mean_rt, fill =block_type, colour =block_type))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =block_type, y =mean_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
    facet_wrap(~task_id)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 7: RT of IAT")
  
  print(IAT_ANOVA)
  print(rt_plot1)
}
IAT_rt_plot(IAT_phase_004_analysis)
```

# IAT的d_prime值
```{r IAT_D}
IAT_D_plot <- function(data) {
IAT_D <- data%>%
  filter(screen_id %in% c(3, 4, 6, 7)) %>%
  filter(rt<=10000)%>%
  group_by(ID,task_id, version) %>%  #task_id是领域(moral,ability),version是block编号，A1是相容练习，A2是相容正式
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n()) %>%
  ungroup()%>%
  pivot_wider(names_from = version, values_from = c(mean_rt, sd_rt,row_n)) %>%
  group_by(ID,task_id) %>% #task_id是领域(moral,ability)
  summarize(
    diff_B1A1 = mean_rt_B1 - mean_rt_A1,
    diff_B2A2 = mean_rt_B2 - mean_rt_A2,
    SD_B1A1 = sqrt((((row_n_A1-1)*(sd_rt_A1^2)+(row_n_B1-1)*(sd_rt_B1^2))+((row_n_A1+row_n_B1)*((mean_rt_A1-mean_rt_B1)^2)/4))/(row_n_A1+row_n_B1-1)),
    SD_B2A2 = sqrt((((row_n_A2-1)*(sd_rt_A2^2)+(row_n_B2-1)*(sd_rt_B2^2))+((row_n_A2+row_n_B2)*((mean_rt_A2-mean_rt_B2)^2)/4))/(row_n_A2+row_n_B2-1)),
   D= round(((diff_B1A1/SD_B1A1) + (diff_B2A2/SD_B2A2))/2, digits = 3))%>%
mutate(
    effect = case_when(
      abs(D) <= 0.2 ~ "small",
      abs(D) <= 0.5 ~ "mid",
      TRUE ~ "big")) #分为moral，ability两个领域的IAT_D
a<-describe(IAT_D)
print(a)

#单算总的D
IAT_D_al <- data%>%
  filter(screen_id %in% c(3, 4, 6, 7)) %>%
  filter(rt<=10000)%>%
  group_by(ID,version) %>%
  summarize(
    mean_rt = mean(rt),
    sd_rt = sd(rt),
    row_n = n()) %>%
  ungroup()%>%
  pivot_wider(names_from = version, values_from = c(mean_rt, sd_rt,row_n)) %>%
  group_by(ID) %>%
  summarize( diff_B1A1 = mean_rt_B1 - mean_rt_A1,
    diff_B2A2 = mean_rt_B2 - mean_rt_A2,
    SD_B1A1 = sqrt((((row_n_A1-1)*(sd_rt_A1^2)+(row_n_B1-1)*(sd_rt_B1^2))+((row_n_A1+row_n_B1)*((mean_rt_A1-mean_rt_B1)^2)/4))/(row_n_A1+row_n_B1-1)),
    SD_B2A2 = sqrt((((row_n_A2-1)*(sd_rt_A2^2)+(row_n_B2-1)*(sd_rt_B2^2))+((row_n_A2+row_n_B2)*((mean_rt_A2-mean_rt_B2)^2)/4))/(row_n_A2+row_n_B2-1)),
    D= round(((diff_B1A1/SD_B1A1) + (diff_B2A2/SD_B2A2))/2, digits = 3)
  )%>%
mutate(
    effect = case_when(
      abs(D) <= 0.2 ~ "small",
      abs(D) <= 0.5 ~ "mid",
      TRUE ~ "big"))%>%
  mutate(task_id="all")%>% #总的IAT_D
bind_rows(IAT_D,.)%>%#将两个子领域的D与总的D合并
  arrange(ID)

print(IAT_D_al)

IAT_result <- ggplot(IAT_D_al, aes(x = task_id, y = D)) +
  geom_boxplot() +  # 不显示异常值
  geom_jitter(aes(color = task_id), width = 0.2, alpha = 0.5) +  # 添加数据点
  labs(x = "Task", y = "D Value", title = "IAT") +
  theme_minimal()
print(IAT_result)

IAT_summary<-IAT_D_al%>%
  group_by(task_id)%>%
   summarise(
    avg_D = mean(D, na.rm = TRUE),
    max_D = max(D, na.rm = TRUE),
    min_D = min(D, na.rm = TRUE),
    sd_D=sd(D, na.rm = TRUE),
lower_95 = quantile(D, 0.025, na.rm = TRUE),  # 下限
    upper_95 = quantile(D, 0.975, na.rm = TRUE))
print(IAT_summary)

IAT_selected_data <- IAT_D_al%>%
  filter(task_id %in% c("moral", "ability"))

# 提取 D 值
morality_D <- IAT_selected_data %>% filter(task_id == "moral") %>% pull(D)
ability_D <- IAT_selected_data %>% filter(task_id == "ability") %>% pull(D)

# 执行配对样本 t 检验
paired_t_test_result <- t.test(morality_D, ability_D, paired = TRUE)

# 输出 t 检验结果
print(paired_t_test_result)

}
IAT_D_plot(IAT_phase_004_analysis)
```


# SRET的评估阶段按键“yes”，RT
```{r SRET EW}
SRET_EW<-function(data){
  
  # EW阶段的yes比例和rt汇总
SRET_EW<-data %>%
  mutate(ID = as.character(ID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("EW_formal") )%>% #选择正式实验的数据
   filter(!word %in% c("务实", "迷糊", "坚贞", "说谎", "主见", "缓慢", "素养", "低俗")) %>%#去掉干扰词
  group_by(ID,person,valence,domain)%>%
  summarize(N_Yes = sum(responses == "yes"),
            N_No = sum(responses == "no"),
            N=n(),
            pro_yes=N_Yes/N,
            avg_rt = mean(rt, na.rm = TRUE),
            sd_rt=sd(rt, na.rm = TRUE)
           )
print(SRET_EW)
a<-describe(SRET_EW)
print(a)

 # 领域（道德，能力）*参照（我，朋友）*效价（积极，消极），方差分析，yes比例
SRET_EW_ANOVA<-SRET_EW%>%
MANOVA(.,
       subID="ID",
       dv="pro_yes",    # 认为词汇描述了参照对象的比例
       within=c("domain","person","valence"),)%>% 
 EMMEANS("valence", by="domain") %>%
  EMMEANS("person", by="domain") %>%
   EMMEANS("person", by="valence") %>%
  EMMEANS(c("valence", "person"), by="domain") %>%
  EMMEANS("person", by=c("domain", "valence")) 
print(SRET_EW_ANOVA)

 # 领域（道德，能力）*参照（我，朋友）*效价（积极，消极），方差分析，rt
SRET_EW_ANOVA2<-SRET_EW%>%
MANOVA(.,
       subID="ID",
       dv="avg_rt",    # 认为词汇描述了参照对象的比例
       within=c("domain","person","valence"),)%>% 
 EMMEANS("valence", by="domain") %>%
  EMMEANS("person", by="domain") %>%
   EMMEANS("person", by="valence") %>%
  EMMEANS(c("valence", "person"), by="domain") %>%
  EMMEANS("person", by=c("domain", "valence")) 
print(SRET_EW_ANOVA2)

 # 领域（道德，能力）*参照（我，朋友）*效价（积极，消极），yes的比例分布
p_EW<-ggplot(SRET_EW, aes(x = person, y = pro_yes, fill = valence)) +
  geom_boxplot(width = 0.1, color = "black", fill = "white", alpha = 0.5, position = position_dodge(width = 0.75)) +
  geom_jitter(aes(color = valence), position = position_jitter(width = 0.15), size = 2, alpha = 0.5, show.legend = FALSE) +
  facet_grid(domain ~ valence) +
  scale_y_continuous(limits = c(0, 1)) +  # 调整纵坐标范围
  scale_fill_manual(values = c("Positive" = "lightblue", "Negative" = "salmon")) +
  scale_color_manual(values = c("Positive" = "blue", "Negative" = "red")) +
  labs(x = "Person", y = "pro_yes", title = "Ew_YES") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)
)
print(p_EW)

# 创建rt的雨云图
  rt_EW_ability <- SRET_EW %>% 
    filter(domain %in% c("ability")) %>%
    ggplot(.,aes(x=person,y=avg_rt, fill =person, colour =person))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =person, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
 facet_wrap(~valence)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 8a: RT of SRET_EW in ability")
  
  rt_EW_moral <-SRET_EW  %>% 
    filter(domain %in% c("morality")) %>%
    ggplot(.,aes(x=person,y=avg_rt, fill =person, colour =person))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =person, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
  facet_wrap(~valence)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 8b: RT of SRET_EW in moral")
  print(rt_EW_ability)
  print(rt_EW_moral)
}
SRET_EW(SRET_phase_004)
```
```{r 计算题}
SRET_math<-function(data){
  
  # EW阶段的yes比例和rt汇总
SRET_math<-data %>%
  mutate(ID = as.character(ID)) %>%
  mutate(rt=as.numeric(rt))%>% #转变被试编号和反应时类型为字符型与数值型
  mutate(correct= as.numeric(correct))%>% ##重编码correct
  filter(screen_id%in%c("SRET_math_calculate") )%>% #选择正式实验的数据
  group_by(ID)%>%
  summarize(n_correct = sum(correct == "1"),
            N=n(),
            mean_rt=mean(rt, na.rm = TRUE),
acc=n_correct/N
           )
print(SRET_math)}
SRET_math(SRET_phase_004)
```


```{r SRET RJ_formal1}
SRET_RJ <- function(data) {
  SRET_RJ <- data %>%
    mutate(ID = as.character(ID),
           rt = as.numeric(rt),
           correct = as.numeric(correct)) %>%
    filter(screen_id %in% c("RJ_formal1")) %>%
    filter(!word %in% c("严谨", "认真", "刻板", "白痴", "忠实", "宽宏", "徇私", "可鄙")) %>%
    mutate(sdt = case_when((identity == "old" & (responses %in% c("familiar", "old"))) ~ "hit",
                          (identity == "old" & (responses == "new" )) ~ "miss",
                          (identity == "new" & (responses %in% c("familiar", "old"))) ~ "fa",
                          (identity == "new" & (responses == "new")) ~ "cr"),) %>%
    group_by(ID,domain, valence ) %>%#, valence
    summarize(
     
      H = sum(sdt == "hit"),
      M = sum(sdt == "miss"),
      FA = sum(sdt == "fa"),
      CR = sum(sdt == "cr"),
      new= sum(responses %in% c("new")),#按键为新词
      old=sum(responses %in% c("old")),
      familiar=sum(responses %in% c("familiar")),
     # P_H = ifelse(H + M == 0, 0, H / (H + M)),
     P_H = H/(H+M),
     P_FA = FA/(FA+CR),
     # P_FA = ifelse(FA + CR == 0, 0, FA / (FA + CR)),
      recognition = (H + CR) / (H + CR + M + FA),
      avg_rt = mean(rt, na.rm = TRUE),
      sd_rt = sd(rt, na.rm = TRUE),
    ) %>%
    mutate(
      P_H2 = ifelse(P_H == 1, 1 - 1 / (2 * (H + M)), P_H),# if hit rate is 1, standardize it
      P_FA2 = ifelse(P_FA == 0, 1 / (2 * (H + M)), P_FA), # if FA rate is 0, standardize it
      Correct_recognition = P_H - P_FA,
      Z_P_H = qnorm(P_H2),
      Z_P_FA = qnorm(P_FA2),
      d_prime = Z_P_H - Z_P_FA) 
  print(SRET_RJ)
  a<-describe(SRET_RJ)
print(a)
  
   SRET_RJ_plot <- SRET_RJ %>% 
    ggplot(.,aes(x=valence,y=avg_rt, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =valence, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
 facet_wrap(~domain)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 9: RT of SRET_RJ ")
   
   print(SRET_RJ_plot)
   
    SRET_RJ_plot2 <- SRET_RJ %>% 
    ggplot(.,aes(x=valence,y=recognition, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =valence, y =recognition),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('recognition')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
 facet_wrap(~domain)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 10: recognition of SRET_RJ ")
    print(SRET_RJ_plot2)
    
     SRET_RJ_plot3 <- SRET_RJ %>% 
    ggplot(.,aes(x=valence,y=d_prime, fill =valence, colour =valence))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =valence, y =d_prime),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('d_prime')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
 facet_wrap(~domain)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 11: d_prime of SRET_RJ ")
    print(SRET_RJ_plot3)
    
    SRET_RJ_ANOV<-SRET_RJ%>%
      MANOVA(.,subID="ID",dv="avg_rt",#Correct_recognition
       within=c("domain","valence"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("domain", by="valence")
    print(SRET_RJ_ANOV)
    
     SRET_RJ_ANOV2<-SRET_RJ%>%
      MANOVA(.,subID="ID",dv="recognition",#Correct_recognition
       within=c("domain","valence"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("domain", by="valence")
     print(SRET_RJ_ANOV2)
     
     SRET_RJ_ANOV3<-SRET_RJ%>%
      MANOVA(.,subID="ID",dv="d_prime",#Correct_recognition
       within=c("domain","valence"))%>%
 EMMEANS("valence", by="domain") %>%
  EMMEANS("domain", by="valence")
     print(SRET_RJ_ANOV3)
     
}

# 调用函数并存储结果
SRET_RJ(SRET_phase_004)
```

```{r SRET RJ_formal2_source_memory}
SRET_Source_M<-function(data){
SRET_RJ_2 <- data %>%
  mutate(ID = as.character(ID)) %>%
  mutate(rt = as.numeric(rt)) %>%
 mutate(correct = as.numeric(coalesce(correct,-1))) %>% #对新词按键判断的试次的correct记为-1
  filter(screen_id %in% c("RJ_formal_2")) %>%
  filter(!word %in% c("严谨", "认真", "刻板", "白痴", "忠实", "宽宏", "徇私", "可鄙")) %>%
   mutate(sdt = case_when((identity == "self" & (correct=="1") )~ "self_hit",
                          #自我条件下的击中，信号是“self”，反应是“self”
                          (identity == "self" & (correct=="0") )~ "self_miss",
                          #自我条件下的漏报，信号是“self”，反应是“friend”
                          (identity == "friend" & (correct=="1" )) ~ "friend_hit",
                          #朋友条件下的击中，信号是“friend”，反应是“friend”
                           (identity == "friend" & (correct=="0" )) ~ "friend_miss",
                          #朋友条件下的漏报，信号是“friend”，反应是“self”
                          (is.na(identity) & (!is.na(response))) ~ "fa",
                          #新词（无信号），反应为self或者friend
                        ) )
print(SRET_RJ_2)

SRET_RJ2_RT<-SRET_RJ_2

SRET_RJ_2<-SRET_RJ_2%>%
  group_by(ID,valence,domain) %>%
  summarize(
    n=n(), #所有按键反应了的试次
   count_self = sum(responses == "self"),#所有反应是“self”的试次
   count_friend = sum(responses == "friend"),#所有反应是“friend”的试次
   self_H = sum(sdt == "self_hit"),#自我条件下的击中，信号是“self”，反应是“self”
   friend_H = sum(sdt == "friend_hit"),#朋友条件下的击中，信号是“friend”，反应是“friend”
    self_M = 10-self_H,# 信号为self，没有被反应为“self
   friend_M = 10-friend_H, # 信号为friend，没有被反应为“friend
      FA = sum(sdt == "fa"),#新词（无信号），反应为self或者friend
      CR = 20-FA,#总共20新词，去掉被判断为旧词（信号）
      self_recognition = self_H /count_self,
   # number of correct source attributions for self/ number of hits for self
   friend_recognition = friend_H/ count_friend,
      avg_rt = mean(rt, na.rm = TRUE),
      sd_rt = sd(rt, na.rm = TRUE),
   max_rt = max(rt, na.rm = TRUE),
    min_rt = min(rt, na.rm = TRUE),
  ) %>%
  pivot_longer(cols = c(self_recognition, friend_recognition),
               names_to = "person",
               values_to = "recognition")%>%
  mutate(person = case_when(
    person == "self_recognition" ~ "self",
    person == "friend_recognition" ~ "friend",
  ))
print(SRET_RJ_2)

a<-describe(SRET_RJ_2)
print(a)

 SRET_RJ2_plot <- SRET_RJ_2 %>% 
    ggplot(.,aes(x=person,y=recognition, fill =person, colour =person))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =person, y =recognition),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
 facet_wrap(~domain)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 10: acc of SRET_RJ ")
   
   print(SRET_RJ2_plot)
   
   SRET_RJ2_plot2 <- SRET_RJ_2 %>% 
    ggplot(.,aes(x=person,y=avg_rt, fill =person, colour =person))+
  geom_flat_violin(position = position_nudge(x = .25, y = 0),adjust =2, trim = FALSE)+
  geom_point(position = position_jitter(width = .15), size = .25)+
  geom_boxplot(aes(x =person, y =avg_rt),outlier.shape = NA, alpha = 0.3, width = .1, colour = "BLACK") +
ylab('rt')+xlab('condition')+coord_flip()+theme_cowplot()+guides(fill = FALSE, colour = FALSE) +
 facet_wrap(~domain)+
  scale_colour_brewer(palette = "Dark2")+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Figure 11: RT of SRET_RJ ")
   
   print(SRET_RJ2_plot2)

}
SRET_Source_M(SRET_phase_004)
```


